<?php

declare(strict_types=1);

namespace Remorhaz\UniLex\Console;

use PhpParser\BuilderFactory;
use PhpParser\Comment\Doc;
use PhpParser\Node\Expr\Array_;
use PhpParser\Node\Expr\ArrayItem;
use PhpParser\Node\Stmt\Declare_;
use PhpParser\Node\Stmt\DeclareDeclare;
use PhpParser\Node\Stmt\Return_;
use PhpParser\PrettyPrinterAbstract;
use ReflectionClass;
use ReflectionException;
use Remorhaz\UniLex\Exception as UniLexException;
use Remorhaz\UniLex\Grammar\ContextFree\GrammarLoader;
use Remorhaz\UniLex\Parser\LL1\Lookup\TableBuilder;
use RuntimeException;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Exception\InvalidOptionException;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

use function array_flip;
use function realpath;
use function sort;

use const SORT_ASC;
use const SORT_STRING;

final class BuildLookupTableCommand extends Command
{

    private const TYPE_LL_1 = 'll-1';

    protected static $defaultName = 'build-lookup-table';

    private $printer;

    private $builder;

    public function __construct(PrettyPrinterAbstract $printer, string $name = null)
    {
        parent::__construct($name);
        $this->printer = $printer;
        $this->builder = new BuilderFactory();
    }

    protected function configure()
    {
        $this
            ->setDescription('Builds parser lookup table.')
            ->addArgument('spec', InputArgument::REQUIRED, 'Grammar specification file')
            ->addArgument('target', InputArgument::REQUIRED, 'Target file')
            ->addOption('type', 't', InputOption::VALUE_REQUIRED, 'Parser type', self::TYPE_LL_1)
            ->addOption('symbol', null, InputOption::VALUE_REQUIRED, 'Class with symbol constants')
            ->addOption('token', null, InputOption::VALUE_REQUIRED, 'Class with token constants')
            ->addOption('desc', 'd', InputOption::VALUE_REQUIRED, 'Lookup table description');
    }

    /**
     * @param InputInterface  $input
     * @param OutputInterface $output
     * @return int
     * @throws UniLexException
     */
    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $output->writeln('Building parser lookup table...');
        $map = $this->buildMap($input, $output);
        $uses = [];

        $symbols = [];
        $symbolsClass = $this->findSymbols($input);
        if (isset($symbolsClass)) {
            $output->writeln("Symbols: {$symbolsClass->getName()}");
            $uses[] = $symbolsClass->getName();
            $symbols = (array) array_flip($symbolsClass->getConstants());
        }

        $tokens = [];
        $tokensClass = $this->findTokens($input);
        if (isset($tokensClass)) {
            $output->writeln("Tokens: {$tokensClass->getName()}");
            $uses[] = $tokensClass->getName();
            $tokens = (array) array_flip($tokensClass->getConstants());
        }

        $description = $this->findDescription($input);
        $descriptionText = isset($description)
            ? "{$description}\n * \n * "
            : '';

        $nodes = [];

        $fileDocText = <<<EOF
/**
 * {$descriptionText}Auto-generated file, please don't edit manually.
 * Generated by UniLex.
 */
EOF;

        $declare =  new Declare_([new DeclareDeclare('strict_types', $this->builder->val(1))]);
        $declare->setDocComment(new Doc($fileDocText));
        $nodes[] = $declare;

        sort($uses, SORT_STRING | SORT_ASC);
        foreach ($uses as $index => $use) {
            $nodes[] = $this->builder->use($use)->getNode();
        }

        $items = [];
        foreach ($map as $symbol => $productions) {
            $productionItems = [];
            foreach ($productions as $token => $production) {
                $productionItems[] = new ArrayItem(
                    $this->builder->val($production),
                    isset($tokens[$token])
                        ? $this->builder->classConstFetch($tokensClass->getShortName(), $tokens[$token])
                        : $this->builder->val($token)
                );
            }
            $items[] = new ArrayItem(
                new Array_($productionItems, ['kind' => Array_::KIND_SHORT]),
                isset($symbols[$symbol])
                    ? $this->builder->classConstFetch($symbolsClass->getShortName(), $symbols[$symbol])
                    : $this->builder->val($symbol)
            );
        }

        $nodes[] = new Return_(
            new Array_($items, ['kind' => Array_::KIND_SHORT])
        );

        $generatedCode = $this->printer->prettyPrintFile($nodes);
        $this->buildTarget($input, $output, $generatedCode);

        return 0;
    }

    private function findDescription(InputInterface $input): ?string
    {
        return $input->getOption('desc');
    }

    /**
     * @param InputInterface  $input
     * @param OutputInterface $output
     * @return array
     * @throws UniLexException
     */
    private function buildMap(InputInterface $input, OutputInterface $output): array
    {
        $specFile = $this->getSpecFile($input);
        $output->writeln("Specification used: {$specFile}");
        $grammar = GrammarLoader::loadFile($specFile);

        return (new TableBuilder($grammar))
            ->getTable()
            ->exportMap();
    }

    private function getSpecFile(InputInterface $input): string
    {
        $specFile = $input->getArgument('spec');
        $specFile = realpath($specFile);
        if (false === $specFile) {
            throw new InvalidOptionException("Argument #1 must contain valid path to specification file");
        }

        return $specFile;
    }

    private function findSymbols(InputInterface $input): ?ReflectionClass
    {
        $className = $input->getOption('symbol');
        if (!isset($className)) {
            return null;
        }

        try {
            return new ReflectionClass($className);
        } catch (ReflectionException $e) {
            throw new InvalidOptionException("Option --symbol must contain valid PHP class", 0, $e);
        }
    }

    private function findTokens(InputInterface $input): ?ReflectionClass
    {
        $className = $input->getOption('token');
        if (!isset($className)) {
            return null;
        }

        try {
            return new ReflectionClass($className);
        } catch (ReflectionException $e) {
            throw new InvalidOptionException("Option --token must contain valid PHP class", 0, $e);
        }
    }

    private function getTargetFile(InputInterface $input): string
    {
        return $input->getArgument('target');
    }

    private function buildTarget(InputInterface $input, OutputInterface $output, string $content): void
    {
        $targetFile = $this->getTargetFile($input);
        $output->writeln("Saving generated data to file {$targetFile}...");

        if (false === file_put_contents($targetFile, $content)) {
            throw new RuntimeException("Failed to write file {$targetFile}");
        }
        $byteCount = strlen($content);
        $output->writeln("Done ({$byteCount} bytes)!");
    }
}
