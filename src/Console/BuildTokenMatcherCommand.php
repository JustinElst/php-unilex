<?php

declare(strict_types=1);

namespace Remorhaz\UniLex\Console;

use ReflectionException;
use Remorhaz\UniLex\Exception;
use Remorhaz\UniLex\Lexer\TokenMatcherGenerator;
use Remorhaz\UniLex\Lexer\TokenMatcherSpec;
use Remorhaz\UniLex\Lexer\TokenMatcherSpecParser;
use RuntimeException;
use Safe;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Exception\InvalidOptionException;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Throwable;

use function array_merge;
use function file_put_contents;
use function realpath;
use function strlen;
use function substr_count;

final class BuildTokenMatcherCommand extends Command
{
    protected static $defaultName = 'build-token-matcher';

    protected function configure(): void
    {
        $this
            ->setDescription('Generates token matcher.')
            ->setHelp('Generates token matcher based on given specification.')
            ->addArgument('spec', InputArgument::REQUIRED, 'Specification file')
            ->addArgument('target', InputArgument::REQUIRED, 'Target file')
            ->addOption('desc', 'd', InputOption::VALUE_REQUIRED, 'Token matcher description');
    }

    /**
     * @throws ReflectionException
     * @throws Exception
     */
    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $output->writeln("Building token matcher...");
        $spec = $this->buildSpec($input, $output);
        $content = $this->buildContent($output, $spec);
        $this->buildTarget($input, $output, $content);

        return 0;
    }

    /**
     * @throws Exception
     * @throws ReflectionException
     */
    private function buildSpec(InputInterface $input, OutputInterface $output): TokenMatcherSpec
    {
        $specFile = $this->getSpecFile($input);
        $output->writeln("Specification used: {$specFile}");

        return TokenMatcherSpecParser::loadFromFile($specFile)
            ->getMatcherSpec()
            ->addFileComment(...$this->getFileComments($input));
    }

    /**
     * @throws Exception
     * @throws ReflectionException
     */
    private function buildContent(OutputInterface $output, TokenMatcherSpec $spec): string
    {
        $generator = new TokenMatcherGenerator($spec);
        $content = $generator->getOutput();
        $byteCount = strlen($content);
        $lineCount = $byteCount > 0
            ? substr_count($content, "\n") + 1
            : 0;
        $output->writeln("Done ({$lineCount} lines)!");

        return $content;
    }

    private function buildTarget(InputInterface $input, OutputInterface $output, string $content): void
    {
        $targetFile = $this->getTargetFile($input);
        $output->writeln("Saving generated data to file {$targetFile}...");

        if (false === file_put_contents($targetFile, $content)) {
            throw new RuntimeException("Failed to write file {$targetFile}");
        }
        $byteCount = strlen($content);
        $output->writeln("Done ({$byteCount} bytes)!");
    }

    private function getTargetFile(InputInterface $input): string
    {
        return $input->getArgument('target');
    }

    private function getSpecFile(InputInterface $input): string
    {
        $specFile = $input->getArgument('spec');
        try {
            return Safe\realpath($specFile);
        } catch (Throwable $e) {
            throw new InvalidOptionException(
                "Argument #1 must contain valid path to specification file",
                previous: $e,
            );
        }
    }

    private function getFileComments(InputInterface $input): array
    {
        $description = $input->getOption('desc');

        return array_merge(
            isset($description) ? [$description, ''] : [],
            [
                "Auto-generated file, please don't edit manually.",
                "Generated by UniLex.",
            ],
        );
    }
}
